"""
This type stub file was generated by pyright.
"""

from seaborn.relational import _RelationalPlotter

__all__ = [
    "catplot",
    "stripplot",
    "swarmplot",
    "boxplot",
    "violinplot",
    "boxenplot",
    "pointplot",
    "barplot",
    "countplot",
]

class _CategoricalPlotterNew(_RelationalPlotter):
    semantics = ...
    wide_structure = ...
    flat_structure = ...
    _legend_func = ...
    _legend_attributes = ...
    def __init__(self, data=..., variables=..., order=..., orient=..., require_numeric=..., legend=...) -> None: ...
    @property
    def cat_axis(self):  # -> str:
        ...
    def plot_strips(self, jitter, dodge, color, edgecolor, plot_kws):  # -> None:
        ...
    def plot_swarms(self, dodge, color, edgecolor, warn_thresh, plot_kws):  # -> None:
        ...

class _CategoricalFacetPlotter(_CategoricalPlotterNew):
    semantics = ...

class _CategoricalPlotter:
    width = ...
    default_palette = ...
    require_numeric = ...
    def establish_variables(self, x=..., y=..., hue=..., data=..., orient=..., order=..., hue_order=..., units=...):
        """Convert input specification into a common representation."""
        ...
    def establish_colors(self, color, palette, saturation):  # -> None:
        """Get a list of colors for the main component of the plots."""
        ...
    @property
    def hue_offsets(self):  # -> Any | NDArray[float64]:
        """A list of center positions for plots when hue nesting is used."""
        ...
    @property
    def nested_width(self):  # -> float:
        """A float with the width of plot elements when hue nesting is used."""
        ...
    def annotate_axes(self, ax):  # -> None:
        """Add descriptive labels to an Axes object."""
        ...
    def add_legend_data(self, ax, color, label):  # -> None:
        """Add a dummy patch object so we can get legend data."""
        ...

class _BoxPlotter(_CategoricalPlotter):
    def __init__(
        self, x, y, hue, data, order, hue_order, orient, color, palette, saturation, width, dodge, fliersize, linewidth
    ) -> None: ...
    def draw_boxplot(self, ax, kws):  # -> None:
        """Use matplotlib to draw a boxplot on an Axes."""
        ...
    def restyle_boxplot(self, artist_dict, color, props):  # -> None:
        """Take a drawn matplotlib boxplot and make it look nice."""
        ...
    def plot(self, ax, boxplot_kws):  # -> None:
        """Make the plot."""
        ...

class _ViolinPlotter(_CategoricalPlotter):
    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        bw,
        cut,
        scale,
        scale_hue,
        gridsize,
        width,
        inner,
        split,
        dodge,
        orient,
        linewidth,
        color,
        palette,
        saturation,
    ) -> None: ...
    def estimate_densities(self, bw, cut, scale, scale_hue, gridsize):  # -> None:
        """Find the support and density for all of the data."""
        ...
    def fit_kde(self, x, bw):  # -> tuple[Unknown | gaussian_kde, Unknown]:
        """Estimate a KDE for a vector of data with flexible bandwidth."""
        ...
    def kde_support(self, x, bw, cut, gridsize):  # -> NDArray[floating[Any]]:
        """Define a grid of support for the violin."""
        ...
    def scale_area(self, density, max_density, scale_hue):  # -> None:
        """Scale the relative area under the KDE curve.

        This essentially preserves the "standard" KDE scaling, but the
        resulting maximum density will be 1 so that the curve can be
        properly multiplied by the violin width.

        """
        ...
    def scale_width(self, density):  # -> None:
        """Scale each density curve to the same height."""
        ...
    def scale_count(self, density, counts, scale_hue):  # -> None:
        """Scale each density curve by the number of observations."""
        ...
    @property
    def dwidth(self): ...
    def draw_violins(self, ax):  # -> None:
        """Draw the violins onto `ax`."""
        ...
    def draw_single_observation(self, ax, at_group, at_quant, density):  # -> None:
        """Draw a line to mark a single observation."""
        ...
    def draw_box_lines(self, ax, data, center):  # -> None:
        """Draw boxplot information at center of the density."""
        ...
    def draw_quartiles(self, ax, data, support, density, center, split=...):  # -> None:
        """Draw the quartiles as lines at width of density."""
        ...
    def draw_points(self, ax, data, center):  # -> None:
        """Draw individual observations as points at middle of the violin."""
        ...
    def draw_stick_lines(self, ax, data, support, density, center, split=...):  # -> None:
        """Draw individual observations as sticks at width of density."""
        ...
    def draw_to_density(self, ax, center, val, support, density, split, **kws):  # -> None:
        """Draw a line orthogonal to the value axis at width of density."""
        ...
    def plot(self, ax):  # -> None:
        """Make the violin plot."""
        ...

class _CategoricalStatPlotter(_CategoricalPlotter):
    require_numeric = ...
    @property
    def nested_width(self):  # -> float:
        """A float with the width of plot elements when hue nesting is used."""
        ...
    def estimate_statistic(self, estimator, errorbar, n_boot, seed):  # -> None:
        ...
    def draw_confints(self, ax, at_group, confint, colors, errwidth=..., capsize=..., **kws):  # -> None:
        ...

class _BarPlotter(_CategoricalStatPlotter):
    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        estimator,
        errorbar,
        n_boot,
        units,
        seed,
        orient,
        color,
        palette,
        saturation,
        width,
        errcolor,
        errwidth,
        capsize,
        dodge,
    ) -> None:
        """Initialize the plotter."""
        ...
    def draw_bars(self, ax, kws):  # -> None:
        """Draw the bars onto `ax`."""
        ...
    def plot(self, ax, bar_kws):  # -> None:
        """Make the plot."""
        ...

class _PointPlotter(_CategoricalStatPlotter):
    default_palette = ...
    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        estimator,
        errorbar,
        n_boot,
        units,
        seed,
        markers,
        linestyles,
        dodge,
        join,
        scale,
        orient,
        color,
        palette,
        errwidth,
        capsize,
        label,
    ) -> None:
        """Initialize the plotter."""
        ...
    @property
    def hue_offsets(self):  # -> Any | NDArray[float64]:
        """Offsets relative to the center position for each hue level."""
        ...
    def draw_points(self, ax):  # -> None:
        """Draw the main data components of the plot."""
        ...
    def plot(self, ax):  # -> None:
        """Make the plot."""
        ...

class _CountPlotter(_BarPlotter):
    require_numeric = ...

class _LVPlotter(_CategoricalPlotter):
    def __init__(
        self,
        x,
        y,
        hue,
        data,
        order,
        hue_order,
        orient,
        color,
        palette,
        saturation,
        width,
        dodge,
        k_depth,
        linewidth,
        scale,
        outlier_prop,
        trust_alpha,
        showfliers=...,
    ) -> None: ...
    def draw_letter_value_plot(self, ax, box_kws=..., flier_kws=..., line_kws=...):  # -> None:
        """Use matplotlib to draw a letter value plot on an Axes."""
        ...
    def plot(self, ax, box_kws, flier_kws, line_kws):  # -> None:
        """Make the plot."""
        ...

_categorical_docs = ...

def boxplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    orient=...,
    color=...,
    palette=...,
    saturation=...,
    width=...,
    dodge=...,
    fliersize=...,
    linewidth=...,
    whis=...,
    ax=...,
    **kwargs
): ...
def violinplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    bw=...,
    cut=...,
    scale=...,
    scale_hue=...,
    gridsize=...,
    width=...,
    inner=...,
    split=...,
    dodge=...,
    orient=...,
    linewidth=...,
    color=...,
    palette=...,
    saturation=...,
    ax=...,
    **kwargs
): ...
def boxenplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    orient=...,
    color=...,
    palette=...,
    saturation=...,
    width=...,
    dodge=...,
    k_depth=...,
    linewidth=...,
    scale=...,
    outlier_prop=...,
    trust_alpha=...,
    showfliers=...,
    ax=...,
    box_kws=...,
    flier_kws=...,
    line_kws=...
): ...
def stripplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    jitter=...,
    dodge=...,
    orient=...,
    color=...,
    palette=...,
    size=...,
    edgecolor=...,
    linewidth=...,
    hue_norm=...,
    native_scale=...,
    formatter=...,
    legend=...,
    ax=...,
    **kwargs
): ...
def swarmplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    dodge=...,
    orient=...,
    color=...,
    palette=...,
    size=...,
    edgecolor=...,
    linewidth=...,
    hue_norm=...,
    native_scale=...,
    formatter=...,
    legend=...,
    warn_thresh=...,
    ax=...,
    **kwargs
): ...
def barplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    estimator=...,
    errorbar=...,
    n_boot=...,
    units=...,
    seed=...,
    orient=...,
    color=...,
    palette=...,
    saturation=...,
    width=...,
    errcolor=...,
    errwidth=...,
    capsize=...,
    dodge=...,
    ci=...,
    ax=...,
    **kwargs
): ...
def pointplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    estimator=...,
    errorbar=...,
    n_boot=...,
    units=...,
    seed=...,
    markers=...,
    linestyles=...,
    dodge=...,
    join=...,
    scale=...,
    orient=...,
    color=...,
    palette=...,
    errwidth=...,
    ci=...,
    capsize=...,
    label=...,
    ax=...
): ...
def countplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    order=...,
    hue_order=...,
    orient=...,
    color=...,
    palette=...,
    saturation=...,
    width=...,
    dodge=...,
    ax=...,
    **kwargs
): ...
def catplot(
    data=...,
    *,
    x=...,
    y=...,
    hue=...,
    row=...,
    col=...,
    col_wrap=...,
    estimator=...,
    errorbar=...,
    n_boot=...,
    units=...,
    seed=...,
    order=...,
    hue_order=...,
    row_order=...,
    col_order=...,
    height=...,
    aspect=...,
    kind=...,
    native_scale=...,
    formatter=...,
    orient=...,
    color=...,
    palette=...,
    hue_norm=...,
    legend=...,
    legend_out=...,
    sharex=...,
    sharey=...,
    margin_titles=...,
    facet_kws=...,
    ci=...,
    **kwargs
): ...

class Beeswarm:
    """Modifies a scatterplot artist to show a beeswarm plot."""

    def __init__(self, orient=..., width=..., warn_thresh=...) -> None: ...
    def __call__(self, points, center):  # -> None:
        """Swarm `points`, a PathCollection, around the `center` position."""
        ...
    def beeswarm(self, orig_xyr):  # -> NDArray[Unknown] | NDArray[Any]:
        """Adjust x position of points to avoid overlaps."""
        ...
    def could_overlap(self, xyr_i, swarm):  # -> ndarray[Any, dtype[Unknown]]:
        """Return a list of all swarm points that could overlap with target."""
        ...
    def position_candidates(self, xyr_i, neighbors):  # -> NDArray[Unknown]:
        """Return a list of coordinates that might be valid by adjusting x."""
        ...
    def first_non_overlapping_candidate(self, candidates, neighbors):
        """Find the first candidate that does not overlap with the swarm."""
        ...
    def add_gutters(self, points, center, log_scale=...):
        """Stop points from extending beyond their territory."""
        ...
